- [首页](../README.md "Java Interview Docs")
1. Redis数据类型与使用场景
   - 5种基本数据类型 string, hash, list, set, zset
   - HyperLogLog, BloomFilter, Bitmap, GeoHash, Stream
   - 分布式锁，异步队列，延时队列，限流，消息
   - 持久化，主从同步，哨兵模式，集群
2. 在写数据的过程中,可以先删除cache,后更新db么?
    - 请求 1 先把 cache 中的 A 数据删除->请求 2从db 中读取数据->请求1 再把db 中的A 数据更新,就会产生数据不一致性的问题
    - 存在更新db失败的风险
3. 在写数据的过程中,先更新 db,后删除 cache 就没有问题了么?
    - 请求 1 从db 读数据 A->请求 2更新 db 中的数据A(此时缓存中无数据A,故不用执行删除缓存操作)->请求 1 将数据A写入 cache
    - 其实概率「很低」,这是因为它必须满足3 个条件:
        - 缓存刚好已失效
        - 读请求+写请求并发
        - 更新数据库+删除缓存的时间(步骤3-4),要比读数据库+写缓存时间短
    - 解决方案:
        - 延迟删:写请求结束后发送mq延迟删除缓存
        - 写请求结束后删除并强制更新缓存,读请求统一设置为setnx更新缓存
4. 可以基于 Set 轻易实现交集(SINTER)、并集(SUNION)、差集的操作(SDIFF),还能随机获取元素SPOP/SRANDMEMBER
5. Redis 默认采用的持久化方式是RDB,会fork 出一个子进程,子进程执行,不会阻塞 Redis 主线程
6. AOF 为什么是在执行完命令之后记录日志?
    - AOF 记录日志不会对命令进行语法检查
    - 不会阻塞当前的命令执行
7. AOF 重写了解吗?
    - AOF 文件重写期间,Redis 还会维护一个 AOF 重写缓冲区,该缓冲区会在子进程创建新 AOF 文件期间,记录服务器执行的所有写命令。
    - 当子进程完成创建新 AOF 文件的工作之后,服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾,
      使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。
    - 最后,服务器用新的 AOF 文件替换旧的AOF 文件,以此来完成 AOF 文件重写操作。
8. AOF 校验机制了解吗?
    - 通过使用一种叫做 校验和(checksum)的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字
    - 如果文件内容发生了变化,那么校验和也会随之改变
9. RDB和AOF对比:RDB体积更小,恢复数据速度更快。但RDB生成的过程更繁重,BGSAVE 子进程会对机器的 CPU 资源和内存影响,并且没法实时或者秒级持久化。
10. Redis 内存碎片产生的原因?
     - Redis向操作系统申请的内存空间可能会大于数据实际需要的存储空间(默认使用jemalloc,而jemalloc 按照一系列固定的大小)
     - 当 Redis 中的某个数据删除时,Redis 通常不会轻易释放内存给操作系统。
11. 在zset元素小于 64 字节且个数小于 128 的时候,会使用ziplist,一旦有序集合中的某个元素超出这两个其中的一个阈值它就会转为 skiplist
12. Redis 跳表的特点:采用双向链表,默认允许最大的层数是 32
13. Redis 的有序集合底层为什么要用跳表,而不用平衡树、红黑树或者 B+树?
    - 跳表使用概率平衡而不是严格强制的平衡,因此,跳表中的插入和删除算法比平衡树的等效算法简单得多,速度也快得多。
    - AVL 树插入操作每一次添加操作都需要进行一次递归定位插入位置,然后还需要根据回溯到根节点检查沿途的各层节点是否失衡,再通过旋转节点的方式进行调整。
    - 相比较于红黑树来说,跳表的实现也更简单一些。并且,按照区间来查找数据这个操作,红黑树的效率没有跳表高。
14. 一般像 MySQL 这类的数据库的 QPS 大概都在 4k 左右(4核 8g),但是使用 Redis 缓存之后很容易达到 5w+
15. Redis 可以做搜索引擎么?
    - Elasticsearch 可以支持 PB 级别的数据量,可以轻松扩展到多个节点,利用分片机制提高可用性和性能
16. Redis6.0 之后为何引入了多线程?为了提高网络 Io 读写性能,Redis 的瓶颈主要受限于内存和网络.执行命令仍然是单线程顺序执行
17. Redis 过期 key 删除策略了解么?
    - Redis 采用的是 定期删除+惰性删除 结合的策略。
    - Redis 的定期删除过程是随机的(周期性地随机从设置了过期时间的key(过期字典)中抽查一批),
      所以并不保证所有过期键都会被立即删除。
    - 这也就解释了为什么有的key 过期了,并没有被删除。
      并且,Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU时间的影响。
    - Redis 7.2 版本为每次抽 20个key,执行时间阈值是 25ms,过期key 比例设定值是 10%
18. 大量 key 集中过期怎么办?
    - 修改 redis.conf 配置文件,将 lazyfree-lazy-expire 参数设置为 yes,即可开启 lazy free 机制。
    - 开启 lazy free 机制后, Redis 会在后台异步删除过期的key,不会阻塞主线程的运行,从而降低对 Redis 性能的影响。
19. Redis 内存淘汰策略:1ru(最久没用到的),1fu(最少使用次数的),tt1(将要过期的),random(随机)
    no-eviction(默认内存淘汰策略):禁止驱逐数据,当内存不足以容纳新写入数据时,新写入操作会报错。
20. 如何发现 bigkey?使用 Redis 自带的 -- bigkeys 参数来查找/借助开源工具分析 RDB 文件
21. 如何发现 hotkey?使用 Redis 自带的 -- hotkeys 参数来查找
22. 慢查询日志(类似于mysq1)
23. 什么是缓存穿透?非法的key 发起大量请求。解决方法:网关限流/参数校验/布隆过滤器
24. 什么是缓存击穿?热点数据过期,导致瞬时大量的请求直接打到了数据库上(秒杀)。解决方法:提前预热/设置互斥锁确保只有一个请求去查询数据库并更新缓存
25. 什么是缓存雪崩?缓存在同一时间大面积过期失效
26. Redis常见类型实现原理
    - String：SDS，是一个带长度信息的字节数组byte[]
    - List：使用quicklist作为数据结构，是ziplist和linkedlist的混合体，将linkedlist按段切分，每一段使用ziplist让存储紧凑。
    - Zset：内部实现是hash字典+skiplist跳跃列表，Redis中的跳跃列表一共有64层，理论上可以容纳2的64次方个元素。每一个节点zslnode包含有kv（存储value-score的关系），节点之间用双向指针串起来。每一层的晋升率是25%。
    - HyperLogLog：提供不精确的去重技术方案，标准误差0.81%。实现原理：给定一系列随机整数，记录低位连续0位的最大长度K，通过K可以估算出随机数的数量N。
    - BloomFilter原理：一个大型的位数组，和几个不一样的无偏hash函数。
    - GeoHash原理：将二维的经纬度数据映射到一维的52位长度整数，放进zset里面。
    - 持久化：快照+增量AOF，快照原理使用操作系统的COW机制，先调用glibc函数fork出一个子进程，当主进程对操作系统的page做修改时，会先将page复制一份分离出来然后对这个复制的页面进行修改，所以子进程遍历到的原始数据是不会变化的。持久化操作通常是由从节点完成的，因为没有来自客户端的请求。
    - 主从同步：当从节点新加入集群的时候，必须先进行一次快照同步，然后才进行增量同步
    - Redis Cluster和Codis最大区别：Redis Cluster是去中心化的，而Codis是中心化的
    - Redis Cluster默认会对key使用crc16算法进行hash得到一个整数值，然后对16384进行取模得到具体槽位。
27. Redis的I/O模型
    - 非阻塞IO：能读多少读多少，能写多少写多少，通过返回值告诉程序实际的读写值。
    - 事件轮询API，是操作系统提供给用户程序的API，比如select，epoll（linux）。输入读写描述符列表，输出对应的读写事件，拿到事件后进程就可以继续挨个处理，处理完了继续轮询。
    - Select和poll在处理大量文件描述符时性能会下降，epoll使用事件驱动的方式，只有在文件描述符实际有事件发生时才通知用户空间，避免了 select 和 poll 的线性扫描开销。
