- [首页](../README.md "Java Interview Docs")
1. volatile keyword:
   - Purpose: Ensures visibility of variable changes across threads
   - Key point: Reads/writes go directly to main memory, not CPU cache
2. synchronized keyword:
   - Purpose: Ensures mutual exclusion + visibility
   - Key point: Only one thread executes the block at a time
3. String Pool: Discussed immutability and JVM’s memory optimization via the string pool.
4. Difference Between ArrayList and LinkedList
   - ArrayList uses a dynamic array internally, which makes it very fast for random access using indices—like get(i). But adding/removing elements in the middle of the list can be costly due to element shifting.
   - LinkedList uses a doubly linked list, which makes insertion and deletion in the middle efficient, as there's no shifting—but accessing elements by index is slow because it has to traverse the list node by node.
5. Java 8 vs Java 17 — Key Features
   - Java 8 Features
     - Stream API
     - Lambda Expressions
         ```java
         Runnable r = () -> System.out.println("Running a thread");
         ```
     - Optional Class
   - Java 17 Features
     - ZGC
     - Text Blocks
     - Record
6. HashMap vs HashTable: Differences in thread safety and synchronization
7. Collection selection: Based on read/write patterns
8. Stream API
9. Difference between @Mock and @Spy in Mockito
   - @Mock
   - @Spy
10. Runnable vs Callable
11. Core Spring Concepts
    - IoC (Inversion of Control): Spring container managing bean lifecycle and dependency injection.
    - AOP (Aspect-Oriented Programming)
12. How Spring Boot Starters autoconfigure a starter
13. Common endpoints in Spring Boot Actuator
14. How to integrate Actuator with Prometheus
15. JPA vs Hibernate vs Mybatis
16. Execution Plans: How to read and optimize query performance
17. Joins: Differences between INNER, LEFT, and RIGHT joins
18. Tables vs Views: Use cases and performance implications
19. Global Exception Handling: Spring Boot provides a very elegant way to handle exceptions globally using two annotations:
      - @ControllerAdvice — to mark a global exception handler class.
      - @ExceptionHandler — to define methods that handle specific exceptions
20. How to integrate with i18n when returning error message?
21. Standards when building production-grade REST APIs
22. Core Components of Kafka
    - Broker: A Kafka server that stores data and serves clients. A Kafka cluster consists of multiple brokers for fault tolerance and scalability.
    - Topic: A logical channel where messages are published and consumed. Topics are divided into partitions for scalability.
    - Producer: An application that publishes messages to a Kafka topic.
    - Consumer: An application that subscribes to a topic to read messages.
    - Partition: A subset of a topic’s data, enabling parallelism and scalability.
    - Offset: A unique identifier for each message in a partition, used to track consumer progress.
23. Azure Services conception and use case
    - Azure Kubernetes Service (AKS)
    - Azure Key Vault use case
    - Azure Blob Storage
    - Azure Service Bus
24. How to use multi-stage builds to reduce docker image size
25. How to integrate Prometheus and Grafana for monitoring
26. How to use Azure Key Vault to securely inject credentials into containers in AKS deployment
27. CI/CD with GitHub Actions and Jenkins
28. Jenkins Pipelines scripts
    - Image tagging and pushing
    - Kubernetes rollouts and health checks
    - Configuration backups and restores
29. Why Use Swagger in Java-based backend development
30. How to integrate with Swagger in Spring Boot Project
31. Common design pattern
    - Singleton Pattern
    - Factory Pattern
    - Strategy Pattern
    - Observer Pattern
    - Chain of Responsibility
32. How to implement centralized logging in microservices using ELK
    - In microservices, each service logs independently, which makes debugging difficult. To handle this, we use centralized logging. Typically, logs are sent from each service to a central log store like Elasticsearch. We then visualize and search logs using Kibana. We also add correlation IDs to trace requests across services. This helps us monitor issues, audit behaviors, and troubleshoot effectively across the entire distributed system.
33. How to link logs across services using micrometer and zipkin
34. SOLID principles
    - Liskov Substitution Principle
    - Interface Segregation Principle
35. Why @Transactional Doesn't Work on Private Methods in Spring
36. Common Git commands and usage

[ref](https://medium.com/@emin_yuce/my-comprehensive-epam-senior-java-engineer-interview-experience-dca8827e92c6)