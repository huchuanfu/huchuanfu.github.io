- [首页](../README.md "Java Interview Docs")
1. volatile keyword:
   - Purpose: Ensures visibility of variable changes across threads
   - Key point: Reads/writes go directly to main memory, not CPU cache
   - prevents instruction reordering
2. synchronized keyword:
   - Purpose: Ensures mutual exclusion + visibility
   - Key point: Only one thread executes the block at a time
3. String Pool: 
   - **Definition**: A special storage area in the Java Heap used to store unique string literals.
   - **Purpose**: Optimizes memory usage by reusing immutable String objects (Flyweight pattern).
   - **Creation Differences**:
     - **Literal** (`String s = "val"`): Checks the pool first. If it exists, returns the reference; otherwise, creates it in the pool.
     - **`new` Keyword** (`new String("val")`): Always creates a new object in the heap, bypassing the pool check (though the literal inside might be pooled).
   - **`intern()`**: A native method that manually adds a string to the pool or returns the existing reference from the pool.
   - **Immutability**: Essential for the pool's integrity. If strings were mutable, changing one reference would affect all other variables pointing to that same pooled string.
4. Difference Between ArrayList and LinkedList
   - ArrayList uses a dynamic array internally, which makes it very fast for random access using indices—like get(i). But adding/removing elements in the middle of the list can be costly due to element shifting.
   - LinkedList uses a doubly linked list, which makes insertion and deletion in the middle efficient, as there's no shifting—but accessing elements by index is slow because it has to traverse the list node by node.
5. Java 8 vs Java 11 vs Java 17 — Key Features
   - Java 8 Features
     - **Stream API**: Functional-style operations on streams of elements (map, filter, reduce) for cleaner data processing.
     - **Lambda Expressions**: Concise syntax for anonymous functions.
         ```java
         Runnable r = () -> System.out.println("Running a thread");
         ```
     - **Optional Class**: A container object to avoid `NullPointerException` and explicit null checks.
     - **Default Methods**: Allows adding new methods to interfaces without breaking implementing classes.
   - Java 11 Features
     - **Local-Variable Syntax for Lambda**: Support for `var` in lambda parameters (e.g., `(var x, var y) -> x + y`).
     - **HTTP Client**: Standardized, non-blocking `HttpClient` supporting HTTP/2 and WebSocket.
     - **ZGC (Experimental)**: Introduced as an experimental scalable low-latency garbage collector (enabled via `-XX:+UseZGC`).
   - Java 17 Features
     - **Text Blocks**: Multi-line string literals using triple quotes `"""`, avoiding escape sequences.
     - **Records**: Concise syntax for immutable data carrier classes.
       ```java
       record Point(int x, int y) {}
       ```
     - **ZGC (Garbage Collector)**: Scalable low-latency GC, now production-ready.
6. HashMap vs Hashtable
   - **Synchronization**: `Hashtable` is synchronized (thread-safe) which creates performance overhead. `HashMap` is not synchronized.
   - **Null Handling**: `HashMap` allows one `null` key and multiple `null` values. `Hashtable` throws `NullPointerException` for any nulls.
   - **Legacy**: `Hashtable` is a legacy class from Java 1.0.
   - **Best Practice**: For thread safety, use `ConcurrentHashMap` instead of `Hashtable`.
7. Collection Selection: Based on read/write patterns
   - **ArrayList**: Best for **Read-Heavy** scenarios. Fast random access (`get(i)` is O(1)), but slow for insertions/deletions in the middle.
   - **LinkedList**: Best for **Write-Heavy** scenarios (insert/delete). Fast modifications (O(1)), but slow random access (O(n)).
   - **HashSet**: Use for **Unique** items where order doesn't matter. Fast O(1) performance.
   - **TreeSet**: Use when **Sorted** unique elements are needed. Slower O(log n) performance.
   - **HashMap**: Standard Key-Value store. Fast O(1) lookups.
   - **ConcurrentHashMap**: Thread-safe map for high concurrency. Uses fine-grained locking (segment locking/CAS) unlike `Hashtable`.
   - **CopyOnWriteArrayList**: Thread-safe list for **Read-Mostly** scenarios (e.g., event listeners). Writes create a new copy of the array.
8. Stream API Samples
   - **Filter & Map**: Selects and transforms elements.
     ```java
     List<String> names = users.stream()
         .filter(u -> u.getAge() > 18)
         .map(User::getName)
         .collect(Collectors.toList());
     ```
   - **Grouping By**: Groups elements by a specific property (Common interview task).
     ```java
     Map<String, List<User>> byCity = users.stream()
         .collect(Collectors.groupingBy(User::getCity));
     ```
   - **FlatMap**: Flattens nested collections (e.g., converting `List<List<String>>` to `List<String>`).
     ```java
     List<String> allSkills = users.stream()
         .flatMap(u -> u.getSkills().stream())
         .collect(Collectors.toList());
     ```
   - **Statistics**: Efficient calculation on primitives.
     ```java
     double avg = users.stream()
         .mapToInt(User::getAge)
         .average().orElse(0);
     ```
9. Difference between @Mock and @Spy in Mockito
   - **@Mock**: Creates a complete dummy object. All method calls return default values (null/0/false) unless explicitly stubbed. Use this to fully isolate the class under test.
   - **@Spy**: Wraps a real object. Real methods are executed unless a specific method is stubbed. Use this for partial mocking (e.g., keeping most logic real but mocking an external call).
   - **Stubbing Difference**:
     - Mock: `when(mock.method()).thenReturn(...)`
     - Spy: `doReturn(...).when(spy).method()` (Prevents the real method from running during the stubbing phase).
10. Runnable vs Callable
    - **Return Value**: `Runnable` returns `void`; `Callable` returns a result (`V`).
    - **Exception Handling**: `Runnable` cannot throw checked exceptions; `Callable` can throw `Exception`.
    - **Method Signature**: `Runnable` uses `run()`; `Callable` uses `call()`.
    - **Usage**: `Callable` is typically used with `ExecutorService` to return a `Future` object.
11. Core Spring Concepts
    - **IoC (Inversion of Control)**:
      - **Concept**: The Spring Container manages object creation and dependencies (Beans) instead of the application doing it manually.
      - **Implementation**: Achieved via **Dependency Injection (DI)** (Constructor, Setter, or Field injection).
      - **Benefit**: Decouples components, facilitating easier testing and maintenance.
    - **AOP (Aspect-Oriented Programming)**:
      - **Concept**: Separates cross-cutting concerns (like logging, security, transactions) from core business logic.
      - **Key Terms**: **Aspect** (the behavior), **Pointcut** (where it applies), and **Advice** (when it runs: Before, After, Around).
    - **Bean Scopes**:
      - **Singleton** (Default): Single instance per Spring container.
      - **Prototype**: New instance created every time it is requested.
12. How to Build a Custom Spring Boot 3.x Starter
    - **Dependencies**: Include `spring-boot-autoconfigure` in your build file.
    - **Properties**: Create a class with `@ConfigurationProperties` to bind `application.properties` values.
    - **AutoConfiguration Class**:
      - Use `@AutoConfiguration` (replaces `@Configuration` for starters).
      - Register beans using `@Bean` and `@ConditionalOnMissingBean` (so users can override them).
      - Enable properties with `@EnableConfigurationProperties`.
    - **Registration**: Create a file `META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports` and add the full class name of your auto-configuration class.
13. Common Endpoints in Spring Boot Actuator
    - `/health`: Checks the application's health (e.g., database, disk space).
    - `/info`: Displays general application information.
    - `/metrics`: Provides detailed application metrics (JVM memory, CPU usage, HTTP requests).
    - `/env`: Shows all environment properties.
    - `/loggers`: Allows viewing and changing logging levels at runtime.
    - `/prometheus`: Exposes metrics formatted for Prometheus scraping (requires the Prometheus micrometer registry).
14. How to Integrate Actuator with Prometheus
    - **1. Add Dependencies**: Include `spring-boot-starter-actuator` and `micrometer-registry-prometheus`.
    - **2. Expose Endpoint**: In `application.properties`, expose the required endpoints: `management.endpoints.web.exposure.include=health,info,prometheus`.
    - **3. Configure Prometheus**: Point your Prometheus server's scrape configuration to your application's `/actuator/prometheus` endpoint.
15. JPA vs Hibernate vs MyBatis vs MyBatis-Plus
    - **JPA (Specification)**: Standard interface for Java ORM. It requires an implementation (like Hibernate).
    - **Hibernate (Full ORM)**:
      - **Features**: Maps Java objects directly to DB tables. Handles caching, dirty checking, and associations automatically.
      - **Best For**: Complex domain models (DDD) where you want to avoid writing SQL.
    - **MyBatis (SQL Mapper)**:
      - **Features**: Maps Java methods to SQL statements. Gives full control over SQL execution and optimization.
      - **Best For**: Complex queries, stored procedures, or when performance tuning is critical.
    - **MyBatis-Plus (Enhanced MyBatis)**:
      - **Features**: An extension of MyBatis that adds built-in CRUD (similar to JPA), pagination, and code generation without writing XML.
      - **Trend**: Extremely popular now because it offers the "best of both worlds"—productivity for simple tasks and flexibility for complex SQL.
16. Execution Plans: How to read and optimize query performance
    - **Key Fields in `EXPLAIN`**:
      - **`type`**: The join type (most critical metric).
      - **`key`**: The index actually used.
      - **`rows`**: Estimated number of rows to examine.
      - **`Extra`**: Vital info like `Using index` (Good, covering index) vs `Using filesort`/`Using temporary` (Bad).
    - **Efficiency Order (`type`)**:
      - `system` > `const` > `eq_ref` > `ref` > `fulltext` > `ref_or_null` > `index_merge` > `unique_subquery` > `index_subquery` > `range` > `index` > `ALL` (Full Table Scan).
    - **Optimization Tips**:
      - **Avoid `SELECT *`**: Fetch only needed columns to enable Covering Indexes.
      - **Optimize `WHERE`**: Avoid functions on indexed columns (e.g., `WHERE YEAR(date) = 2023` breaks index).
      - **Join Optimization**: Ensure join columns are indexed and data types match.
      - **Check `Extra`**: Eliminate `Using filesort` by aligning indexes with sorting.
17. Joins: Differences between INNER, LEFT, and RIGHT joins
    - **INNER JOIN**: Returns only rows with matching values in **both** tables.
    - **LEFT JOIN**: Returns **all** rows from the left table and matched rows from the right. Returns `NULL` for right-side columns if no match found.
    - **RIGHT JOIN**: Returns **all** rows from the right table and matched rows from the left. (Less common, usually replaced by swapping tables in a LEFT JOIN).
    - **Performance**: INNER JOIN is generally faster as it processes fewer rows (filters non-matches early), provided join columns are indexed.
18. Tables vs Views: Use cases and performance implications
    - **Definition**:
      - **Table**: Physical structure storing actual data on disk.
      - **View**: A virtual table (saved SQL query). It does not store data itself (except Materialized Views).
    - **Use Cases for Views**:
      - **Security**: Expose only specific columns/rows to users (e.g., hide `salary` column).
      - **Simplicity**: Encapsulate complex joins or aggregations into a single virtual table.
    - **Performance**:
      - **Standard View**: No performance gain. The DB executes the underlying query every time.
      - **Materialized View**: Physically stores result data. Drastically improves read performance for complex queries but adds overhead for data updates.
19. Global Exception Handling: Spring Boot provides a very elegant way to handle exceptions globally using two annotations:
      - @ControllerAdvice — to mark a global exception handler class.
      - @ExceptionHandler — to define methods that handle specific exceptions
20. How to integrate with i18n when returning error message?
    - **1. Define Messages**: Create `messages.properties` and locale-specific files (e.g., `messages_zh.properties`) in `src/main/resources`.
    - **2. Resolve Locale**: Spring Boot uses `AcceptHeaderLocaleResolver` by default, resolving locale from the HTTP `Accept-Language` header.
    - **3. Global Handler Implementation**:
      - Inject `MessageSource` into your `@ControllerAdvice` class.
      - In the `@ExceptionHandler` method, retrieve the message:
        ```java
        String msg = messageSource.getMessage("error.user.not.found", null, LocaleContextHolder.getLocale());
        ```
21. Standards when building production-grade REST APIs
    - **Resource Naming**: Use **nouns** (not verbs) and **plural** forms (e.g., `/users` not `/getUser`). Use hierarchy for relationships (`/users/{id}/orders`).
    - **HTTP Methods**: Use standard verbs: `GET` (read), `POST` (create), `PUT` (full update), `PATCH` (partial update), `DELETE` (remove).
    - **Status Codes**: Return precise codes:
      - `200 OK`, `201 Created`, `204 No Content`.
      - `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`.
      - `500 Internal Server Error`.
    - **Versioning**: Essential for backward compatibility. Use URI versioning (`/v1/users`) or Header versioning (`Accept-version: v1`).
    - **Pagination & Filtering**: Never return full datasets. Use query params: `?page=1&size=10&sort=name,desc`.
    - **Statelessness**: The server should not store client state (Session). Use tokens (JWT) for authentication.
    - **Idempotency**: Ensure `GET`, `PUT`, `DELETE` are idempotent (repeating the request produces the same result).
22. Core Components of Kafka
    - Broker: A Kafka server that stores data and serves clients. A Kafka cluster consists of multiple brokers for fault tolerance and scalability.
    - Topic: A logical channel where messages are published and consumed. Topics are divided into partitions for scalability.
    - Producer: An application that publishes messages to a Kafka topic.
    - Consumer: An application that subscribes to a topic to read messages.
    - Partition: A subset of a topic’s data, enabling parallelism and scalability.
    - Offset: A unique identifier for each message in a partition, used to track consumer progress.
23. Azure Services conception and use case
    - **Azure Kubernetes Service (AKS)**: Managed Kubernetes for deploying, scaling, and managing containerized applications (Microservices).
    - **Azure Key Vault**: Securely stores secrets, keys, and certificates. Used to inject sensitive config (DB passwords, API keys) into apps without hardcoding.
    - **Azure Blob Storage**: Object storage for massive amounts of unstructured data (images, logs, backups).
    - **Azure Front Door**: Global load balancer and CDN. Optimizes performance and provides high availability for global web apps.
    - **Azure Service Bus**: Enterprise message broker (Queues/Topics) for decoupling distributed systems and handling asynchronous processing.
24. How to use multi-stage builds to reduce docker image size
    - **Concept**: Separate the build environment (Maven/Gradle + SDK) from the runtime environment (JRE only).
    - **Steps**:
      1. **Build Stage**: Use a heavy image (e.g., `maven:3.8-openjdk-17`) to compile code.
      2. **Runtime Stage**: Use a minimal image (e.g., `eclipse-temurin:17-jre-alpine`).
      3. **Copy**: Copy only the JAR file from the build stage.
      ```dockerfile
      FROM maven:3.8 AS build
      COPY . /app
      RUN mvn package
      FROM eclipse-temurin:17-jre-alpine
      COPY --from=build /app/target/*.jar app.jar
      ENTRYPOINT ["java", "-jar", "/app.jar"]
      ```
25. How to integrate Prometheus and Grafana for monitoring
    - **1. App Configuration**: Ensure Spring Boot Actuator exposes the `/prometheus` endpoint (see Point 14).
    - **2. Prometheus Config (`prometheus.yml`)**: Add a scrape job targeting the application service.
      ```yaml
      scrape_configs:
        - job_name: 'spring-app'
          metrics_path: '/actuator/prometheus'
          static_configs:
            - targets: ['host.docker.internal:8080']
      ```
    - **3. Grafana Setup**:
      - Add Prometheus as a **Data Source**.
      - Import a **Dashboard** (e.g., ID 4701 for JVM Micrometer) to visualize metrics like Heap usage, GC, and CPU.
26. How to use Azure Key Vault to securely inject credentials into containers in AKS deployment
    - **1. Enable CSI Driver**: Install the **Secrets Store CSI Driver** on the AKS cluster.
    - **2. Identity Access**: Grant the AKS Managed Identity `Get` and `List` permissions on the Azure Key Vault.
    - **3. SecretProviderClass**: Create a K8s resource mapping the Key Vault secret to a file.
    - **4. Pod Volume Mount**: Update `deployment.yaml` to mount the secrets store as a volume.
      ```yaml
      volumes:
        - name: secrets-store
          csi:
            driver: secrets-store.csi.k8s.io
            volumeAttributes:
              secretProviderClass: "my-azure-kv"
      ```
    - **5. Usage**: The application reads the secret from the mounted file path (e.g., `/mnt/secrets/db-password`) instead of an environment variable.
27. How to integrate Jenkins CI/CD with GitHub Actions
    - **Scenario**: Using GitHub Actions for lightweight checks and triggering Jenkins for complex deployments.
    - **1. Jenkins API Token**: Generate a token in Jenkins for a user with build permissions.
    - **2. GitHub Secrets**: Store Jenkins URL, User, and Token in GitHub Repository Secrets.
    - **3. GitHub Action Workflow**: Use a step to trigger the Jenkins job via HTTP request.
      ```yaml
      - name: Trigger Jenkins Job
        run: |
          curl -X POST https://jenkins.example.com/job/deploy-job/build \
          --user ${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_TOKEN }}
      ```
    - **4. Reverse Integration**: Jenkins updates the GitHub Commit Status (Pending/Success) using the **GitHub Plugin** to block/allow merges.
28. Jenkins Pipelines scripts (CI/CD for AKS)
    - **CI Pipeline (Build & Push)**:
      - **Steps**: Checkout Code -> Build JAR (Maven) -> Build Docker Image -> Login to ACR -> Push Image.
      - **Script**:
        ```groovy
        pipeline {
            agent any
            environment {
                ACR_URL = "myregistry.azurecr.io"
                IMAGE = "${ACR_URL}/myapp:${env.BUILD_NUMBER}"
                ACR_CRED = "acr-creds-id" // Jenkins Credential ID
            }
            stages {
                stage('Checkout') { steps { git 'https://github.com/user/repo.git' } }
                stage('Build JAR') { steps { sh 'mvn clean package -DskipTests' } }
                stage('Docker Push') {
                    steps {
                        script {
                            // Uses Docker Pipeline plugin to build and push
                            docker.withRegistry("https://${ACR_URL}", "${ACR_CRED}") {
                                docker.build(IMAGE).push()
                            }
                        }
                    }
                }
            }
        }
        ```
    - **CD Pipeline (Deploy to AKS)**:
      - **Steps**: Authenticate (Kubeconfig) -> Update Deployment Image -> Verify Rollout.
      - **Script**:
        ```groovy
        pipeline {
            agent any
            parameters { string(name: 'IMAGE_TAG', description: 'Tag to deploy') }
            stages {
                stage('Deploy to AKS') {
                    steps {
                        // Uses Kubernetes CLI Plugin
                        withKubeConfig([credentialsId: 'aks-kubeconfig-id']) {
                            // Update the image in the existing deployment
                            sh "kubectl set image deployment/myapp-deployment myapp-container=myregistry.azurecr.io/myapp:${params.IMAGE_TAG}"
                            // Wait for rollout to complete
                            sh "kubectl rollout status deployment/myapp-deployment"
                        }
                    }
                }
            }
        }
        ```
29. Why Use Swagger (OpenAPI)
    - **Interactive Documentation**: Visualizes API resources, allowing developers/testers to execute requests directly in the browser.
    - **Sync with Code**: Auto-generated from code, ensuring documentation never gets out of date compared to manual wikis.
    - **Client SDK Generation**: Can generate client libraries (Angular, React, Java, etc.) automatically.
    - **Standardization**: Adheres to OpenAPI Specification (OAS), facilitating integration with tools like Postman or API Gateways.
30. How to integrate with Swagger in Spring Boot (SpringDoc)
    - **Dependency**: Add `springdoc-openapi-starter-webmvc-ui` (Standard for Spring Boot 3.x).
    - **Configuration**:
      - **Global Info**: Use `@OpenAPIDefinition(info = @Info(title = "My API", version = "v1"))`.
      - **Endpoint Details**: Use `@Operation(summary = "Get User")` on controller methods.
    - **Access**: Navigate to `http://localhost:8080/swagger-ui/index.html`.
31. Common design pattern
    - **Singleton Pattern**:
      - **Concept**: Ensures a class has only one instance and provides a global access point.
      - **Spring Usage**: The default scope for all beans. The Spring container creates and manages a single instance of a bean, injecting the same instance wherever it's autowired.
    - **Factory Pattern**:
      - **Concept**: Creates objects without exposing the instantiation logic to the client.
      - **Spring Usage**: The `ApplicationContext` itself is a factory for beans. The `FactoryBean` interface is a more specific example, used to create complex objects (e.g., proxies, service clients) that require custom initialization logic.
    - **Strategy Pattern**:
      - **Concept**: Encapsulates a family of algorithms and makes them interchangeable.
      - **Spring Usage**: Used extensively in Spring Security, where different `AuthenticationProvider`s represent different authentication strategies (e.g., username/password, JWT, LDAP). The system selects the appropriate strategy at runtime.
    - **Observer Pattern**:
      - **Concept**: When one object changes state, all its dependents are notified automatically.
      - **Spring Usage**: Implemented via Spring's event model. Publishing an `ApplicationEvent` notifies all beans that are listening for that event with `@EventListener`, decoupling event producers from consumers.
    - **Chain of Responsibility**:
      - **Concept**: Passes a request along a chain of handlers.
      - **Spring Usage**: The core of Spring Security's `FilterChainProxy`. An HTTP request passes through a chain of filters, each handling a specific task like authentication or header security. Spring MVC `HandlerInterceptor`s also form a chain.
    - **Template Method Pattern**:
      - Define the main structure in a base class
      - Allow subclasses to override certain steps without changing the overall algorithm structure
32. How to implement centralized logging in microservices using ELK
    - In microservices, each service logs independently, which makes debugging difficult. To handle this, we use centralized logging. 
    - Typically, logs are sent from each service to a central log store like Elasticsearch. We then visualize and search logs using Kibana. 
    - We also add correlation IDs to trace requests across services. This helps us monitor issues, audit behaviors, and troubleshoot effectively across the entire distributed system.
33. How to link logs across services using Micrometer and Zipkin
    - **Concept**: Distributed tracing assigns a unique **Trace ID** to a request chain and a **Span ID** to each specific operation.
    - **1. Dependencies**: Add `micrometer-tracing-bridge-brave` (to generate traces) and `zipkin-reporter-brave` (to send them to Zipkin).
    - **2. Configuration**:
      - **Sampling**: `management.tracing.sampling.probability=1.0` (100% for dev, lower for prod).
      - **Endpoint**: `management.zipkin.tracing.endpoint=http://localhost:9411/api/v2/spans`.
    - **3. Log Correlation**: Spring Boot 3 automatically injects IDs into MDC. Ensure `logging.pattern.console` includes `%X{traceId} %X{spanId}`.
    - **4. Visualization**: Start Zipkin server and search by Trace ID to see the full request latency breakdown across services.
34. SOLID + 2 Principles (7 Total)
    - **Single Responsibility (SRP)**: A class should have only one reason to change.
    - **Open/Closed (OCP)**: Open for extension, closed for modification. Use interfaces/abstract classes.
    - **Liskov Substitution (LSP)**: Subtypes must be substitutable for their base types without altering correctness.
    - **Interface Segregation (ISP)**: Clients shouldn't depend on interfaces they don't use. Split large interfaces.
    - **Dependency Inversion (DIP)**: Depend on abstractions, not concretions. High-level modules shouldn't depend on low-level ones.
    - **Composite Reuse (CARP)**: Prefer composition (has-a) over inheritance (is-a) to reduce coupling.
    - **Law of Demeter (LoD)**: Talk only to your immediate friends. Don't call methods on objects returned by other methods (`a.getB().getC()` is bad).
35. Why @Transactional Doesn't Work on Private Methods in Spring
    - **Proxy-Based AOP**: Spring applies transactions using AOP proxies (JDK or CGLIB) that wrap your bean.
    - **External Calls Only**: The proxy intercepts calls coming *from outside* the object.
    - **Internal Call Bypass**: When a public method calls a private method within the same class (`this.privateMethod()`), it is a direct internal call. This call does not go through the proxy.
    - **Conclusion**: Since the proxy is bypassed, the transactional advice is never triggered.
36. Common Git commands and usage
    - **`git pull`**: Fetches and merges changes from the remote branch into your local branch.
    - **`git push`**: Uploads your local commits to the remote repository.
    - **`git rebase -i [base-branch]`**: Interactive rebase. Used to squash multiple commits into one for a cleaner history before merging a feature branch.
    - **`git cherry-pick [commit-hash]`**: Applies a specific commit from another branch to the current branch. Essential for applying hotfixes.
    - **`git stash`**: Temporarily shelves uncommitted changes, allowing you to switch branches. Use `git stash pop` to re-apply.
    - **`git revert [commit-hash]`**: Creates a new commit that undoes the changes of a previous commit. It's the safe way to undo changes in a shared/public branch.
37. High Cohesion, Low Coupling
    - High cohesion means that the elements within a module or class are strongly related and focused on a single responsibility.
    - Low coupling means that modules or classes have minimal dependencies on each other.

[My Comprehensive EPAM Senior Java Engineer Interview Experience](https://medium.com/@emin_yuce/my-comprehensive-epam-senior-java-engineer-interview-experience-dca8827e92c6)
[EPAM Senior Java Engineer Interview Questions and Answers](https://medium.com/@g.edwinlal/epam-senior-java-engineer-interview-questions-and-answers-d370ce197fb7)
[EPAM Systems Senior Java Developer Interview Questions and Answers](https://www.ambitionbox.com/interviews/epam-systems-interview-questions/senior-java-developer)
[EPAM Systems Senior Java Developer Interview questions with answers](https://www.fdaytalk.com/epam-systems-senior-java-developer-interview-questions-with-answers/)