- [首页](../README.md "Java Interview Docs")
1. ApplicationContext的两个常用实现类AnnotationConfigApplicationContext和ClassPathXmlApplicationContext
    - your application code should never use them. Indeed, your application code should have no calls to the getBean() method at all and thus have no dependency on Spring APIs at all
2. BeanDefinition里包含了bean的定义如name、scope、class，容器会根据这些定义去实例化bean
3. bean的依赖注入有两种方式：构造方法(for mandatory dependencies)和setter(for optional dependencies)
4. 如果A中depends on B，那么在初始化时B会先于A被初始化，而在销毁时A会先于B被销毁
5. 当@Lazy的bean被其它非lazy-initialized bean所依赖的时候，注解会失效，仍然会在启动时立即初始化
6. @Lookup注解通常用于在单例bean中每次都能获取一个非单例的依赖bean（也可以使用aware接口自己去getBean）
7. 方法注入是基于cglib的字节码技术生成子类来实现的
8. 不推荐使用InitializingBean和DisposableBean,而是使用@PostConstruct和@PreDestroy,或者@Bean(initMethod/destroyMethod = "init")
9. @PostConstruct -> afterPropertiesSet() -> initMethod, @PreDestroy -> DisposableBean.destroy() -> destroyMethod
   @PostConstruct是在CommonAnnotationBeanPostProcessor中被处理和调用的(通过反射调用,无视private)
10. BeanFactoryPostProcessor用于Bean 定义加载之后,Bean 实例化之前进行修改。
    BeanPostProcessor用于Bean 实例化之后,初始化之前,对 Bean 进行修改。
11. 捕获全局异常只需要在项目中配置 @RestControllerAdvice和 @ExceptionHandler就可以
12. Spring AOP是基于动态代理实现的,JDK proxy和cglib字节码技术
    - 如果要代理的对象实现了某个接口，那么 Spring AOP 会使用 JDK Proxy，去创建代理对象
    - 而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 Cglib 生成一个被代理对象的子类来作为代理
13. Spring 并不直接管理事务,而是提供了多种事务管理器。
    - Spring 事务管理器的接口是:PlatformTransactionManager
    - 通过这个接口,Spring 为各个平台如:JDBC(DataSourceTransactionManager)、Hibernate(HibernateTransactionManager)、JPA(JpaTransactionManager)
      等都提供了对应的事务管理器,但是具体的实现就是各个平台自己的事情了(doCommit、doRollback等接口)
    - 通过模板方法模式在AbstractPlatformTransactionManager中定义了事务管理的骨架流程，而将具体的数据源操作实现委托给子类实现
14. 事务传播行为:
    - PROPAGATION_REQUIRED(当前存在事务,则加入该事务;如果当前没有事务,则创建一个新的事务)
    - PROPAGATION_REQUIRES_NEW(a滚b不滚)
    - PROPAGATION_NESTED (a滚b也滚)
    - PROPAGATION_MANDATORY(当前存在事务,则加入该事务;如果当前没有事务,则抛出异常)
15. @Transactional 注解失效有哪些情况
    - 非public方法
    - 在同一个类中的其他方法内部调用
    - 被 @Transactional 注解的方法所在的类必须被 Spring 管理,否则不生效
    - 底层使用的数据库必须支持事务机制,否则不生效
16. @Transactional 事务注解原理
    - @Transactional 的工作机制是基于 AOP 实现的,AOP 又是使用动态代理实现的。
    - 如果一个类或者一个类中的 public 方法上被标注@Transactional 注解的话，Spring 容器就会在启动的时候为其创建一个代理类
    - 在调用被@Transactional 注解的 public 方法的时候，实际调用的是TransactionInterceptor 类中的 invoke()方法
    - 这个方法的作用就是在目标方法之前开启事务，方法执行过程中如果遇到异常的时候回滚事务，方法调用完成之后提交事务
17. application context refresh执行成功就视为liveness,application and command-line runners执行成功才视为readiness
18. EnvironmentPreparedEvent -> ContextPreparedEvent -> StartedEvent -> Runner -> ReadyEvent
19. PropertySourceLoader策略模式实现YamlPropertySourceLoader和PropertiesPropertySourceLoader
20. Spring中的设计模式:
    - Spring
      - 单例-Spring 中的 Bean 默认都是单例的
      - 代理-Spring AOP 功能的实现
      - 工厂-Spring 使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
    - Spring MVC
      - 策略-HandlerMapping 根据 URL 去匹配查找能处理的 Handler，AntPathMatcher
      - 适配器-DispatcherServlet 调用 HandlerAdapter适配器执行 Handler
    - Spring Boot
      - 模板-Spring bean,onRefresh方法初始化webServer
      - 观察者模式-SpringApplicationRunListener（监听应用启动阶段事件）
21. SprngMVC工作原理
    - RequestMappingHandlerMapping -> afterPropertiesSet -> registry.put(mapping,handler)
      RequestMappingHandlerAdapter -> afterPropertiesSet -> ArgumentResolvers/ReturnValueHandler
    - 当一个request来,先经过filter调用链,再到tomcat的HttpServlet,然后到FrameworkServlet的service,最后到DispatcherServlet的service
    - 根据Servlet规范,各组件的加载 顺序如下:listener ->filter ->servlet
22. SpringBoot启动流程
    - 获取运行监听器SpringApplicationRunListeners
    - 准备环境和配置，加载默认配置和用户自定义yml配置
    - 创建和准备容器AnnotationConfigApplicationContext，调用refreshContext
        - 创建bean
        - 自动装配
        - 初始化内嵌web服务器（tomcat/netty）
    - ApplicationRunner和CommandLineRunner
23. Spring如何解决bean循环依赖
    - Spring 通过三级缓存解决了循环依赖，其中，一级缓存为单例池（singletonObjects），二级缓存为早期曝光对象 earlySingletonObjects，三级缓存为早期曝光对象工厂（singletonFactories）
    - 当 A、B 两个类发生循环引用时，在 A 完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中
      - 如果 A 被 AOP 代理，那么，通过这个工厂获取到的就是 A 代理后的对象，
      - 如果 A 没有被 AOP 代理，那么，这个工厂获取到的就是 A 实例化的对象。
    - 当 A 进行属性注入时，会去创建 B，同时，B 又依赖了 A，所以，创建 B 的同时又会去调用 getBean(a) 来获取需要的依赖，此时的 getBean(a) 会从缓存中获取
      - 第一步，先获取到三级缓存中的工厂；
      - 第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到 B 中。紧接着 B 会走完它的生命周期流程，包括初始化、后置处理器等。
      - 当 B 创建完后，会将 B 再注入到 A 中，此时， A 再完成它的整个生命周期。
24. Bean的生命周期
    ```
      → Instantiation
      → Populate
      → Aware回调
      → BeanPostProcessor Before
      → @PostConstruct
      → InitializingBean.afterPropertiesSet()
      → initMethod
      → BeanPostProcessor After
      → @PreDestroy
      → DisposableBean.destroy()
      → destroyMethod
    ```
25. SpringBoot 4.0新特性
    - 通过AOT编译将应用转化为原生镜像，实现冷启动时间降低90%，内存占用减少80%
    - 基于JDK 21的虚拟线程特性，Spring Boot 4.0重构线程池模型以支持百万级并发
    - RequestMapping引入了version进行版本控制
    - 声明式HTTP客户端
26. Spring,Spring MVC,Spring Boot 之间什么关系?
    - Spring 包含了多个功能模块，其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块，Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块
    - Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。
    - 使用 Spring 进行开发各种配置过于麻烦比如开启某些 Spring 特性时，需要用 XML 或 Java 进行显式配置。于是，Spring Boot 诞生了！
    - Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！
27. @Component 和 @Bean 的区别是什么
    @Component 注解作用于类，而@Bean注解作用于方法
    @Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我
    @Bean 注解比 @Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现（比如restTemplate）
28. @Autowired 和 @Resource 的区别是什么
    - @Autowired 是 Spring 提供的注解，@Resource 是 JDK 提供的注解。
    - Autowired 默认的注入方式为byType（根据类型进行匹配），@Resource默认注入方式为 byName（根据名称进行匹配）。
    - 当一个接口存在多个实现类的情况下，@Autowired 和@Resource都需要通过名称才能正确匹配到对应的 Bean。
      - Autowired 可以通过 @Qualifier 注解来显式指定名称，@Resource可以通过 name 属性来显式指定名称。
29. 注入 Bean 的方式有哪些
    - 构造函数注入：通过类的构造函数来注入依赖项。（官方推荐）
    - Setter 注入：通过类的 Setter 方法来注入依赖项。
    - Field（字段） 注入：直接在类的字段上使用注解（如 @Autowired
30. Bean 的作用域有哪些
    - singleton : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。
    - prototype : 每次获取都会创建一个新的 bean 实例。也就是说，连续 getBean() 两次，得到的是不同的 Bean 实例。
    - request （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。
    - session （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。
    - (可以通过实现Scope接口来自定义新的scope,通过beanFactory.registerScope注册到容器)
31. SpringMVC工作原理
    - 客户端（浏览器）发送请求， DispatcherServlet拦截请求。
    - DispatcherServlet 根据请求信息调用 HandlerMapping 。HandlerMapping 根据 URL 去匹配查找能处理的 Handler（也就是我们平常说的 Controller 控制器） ，并会将请求涉及到的拦截器和 Handler 一起封装。
    - DispatcherServlet 调用 HandlerAdapter适配器执行 Handler 。
    - Handler 完成对用户请求的处理后，会返回一个 ModelAndView 对象给DispatcherServlet，ModelAndView 顾名思义，包含了数据模型以及相应的视图的信息。Model 是返回的数据对象，View 是个逻辑上的 View。
    - ViewResolver 会根据逻辑 View 查找实际的 View。
    - DispaterServlet 把返回的 Model 传给 View（视图渲染）。
    - 把 View 返回给请求者（浏览器）
32. BeanFactory和FactoryBean的区别
    - BeanFactory：核心容器接口，负责管理和提供 Bean 实例，提供了基本的 Bean 管理功能
    - FactoryBean：用于自定义 Bean 实例的创建过程，可以创建复杂或动态的 Bean 实例，提供了额外的控制能力
    - ApplicationContext 实际上也继承自 BeanFactory
33. SpringBoot 是如何实现自动装配的
    - SpringBoot 的核心注解 SpringBootApplication，可以看做是@Configuration、@EnableAutoConfiguration、@ComponentScan注解的集合
    - 其中@EnableAutoConfiguration 是实现自动装配的重要注解，主要用于获取所有符合条件的类的全限定类名，这些类需要被加载到 IoC 容器中。
    - 通过读取META-INF/spring.factories（所有 Spring Boot Starter 下的META-INF/spring.factories都会被读取到），结合@ConditionalOnXXX 中的所有条件都满足，该类才会加载