- [首页](../README.md "Java Interview Docs")
1. CAP 定理(CAP theorem)指出对于一个分布式系统来说,当设计读写操作时,只能同时满足以下三点中的两个:
    - 一致性(Consistency):所有节点访问同一份最新的数据副本
    - 可用性(Availability):非故障的节点在合理的时间内返回合理的响应(不是错误或者超时的响应)。
    - 分区容错性(Partition Tolerance):分布式系统出现网络分区的时候,仍然能够对外提供服务。
2. Spring Cloud Gateway 和 Zuul 2.x 的差别不大,也是通过过滤器来处理请求。  
   不过,目前更加推荐使用 Spring Cloud Gateway 而非 Zuul,Spring Cloud 生态对其支持更加友好。
3. 最常用的网关有 Spring Cloud Gateway、Kong、APISIX 这三个
4. Spring Cloud Gateway 的工作流程?
    - 路由判断:客户端的请求到达网关后先经过 Gateway Handler Mapping 处理,里面会做断言(Predicate)判断看符合哪个路由规则,这个路由映射后端的某个服务
    - Pre-Filters->后端服务对请求进行处理 ->Post-Filters
5. Spring Cloud Gateway 如何实现动态路由?
   基于 Nacos 注册中心,从注册中心获取服务的元数据(例如服务名称、路径等),然后根据这些信息自动生成路由规则
6. UUID 的优缺点:存储消耗空间大/无序(非自增)会严重影响数据库性能
7. 分布式id生成方式有哪些?
    - Snowflake雪花算法/Redis/基于数据库的号段模式
8. 分布式锁的常见实现方式有哪些?
    - 基于关系型数据库比如 MySQL 实现分布式锁。
    - 基于分布式协调服务 ZooKeeper 实现分布式锁。
    - 基于分布式键值存储系统比如 Redis、Etcd 实现分布式锁。
9. Redisson提供了一个专门用来监控和续期锁的Watch Dog(看门狗),默认情况下,每过10秒,看门狗就会执行续期操作,将锁的超时时间设置为30 秒
10. Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁,
    如果客户端能能够和半数以上的实例成功地完成加锁操作,那么我们就认为,客户端成功地获得分布式锁,否则加锁失败
11. Seata的AT模式两阶段提交和传统的两阶段提交有什么区别?
    - AT模式的一阶段会提交业务数据和记录undo log,释放本地锁和资源。
    - Seata会拦截业务sq1,生成before和after image,最后生成行锁。
    - 二阶段如果确认成功,TC会通知RM异步删除undo log和行锁。如果失败,TM会向TC发起回滚请求,TC通知RM根据XID和branch id找到对应的undo 1og进行回滚。
    - 在AT模式中,参与者的本地事务执行成功后即可提交,而不需要等待其他参与者的状态
12. JWT 结构
    - Header：签名所使用的算法、令牌类型（一般为 JWT），然后将它进行 Base64URL 编码，得到 JWT 的第一部分
    - Payload：存放需要传递的 声明（Claims），如用户信息、权限、过期时间等
    - Signature：用于验证令牌的完整性和可信性，防止内容被篡改（前面两部分内容加起来进行加密）
13. JWT 的优势
    - 无状态：JWT 自身包含了身份验证所需要的所有信息，因此，我们的服务器不需要存储 Session 信息
    - 有效避免了 CSRF 攻击：CSRF 攻击需要依赖 Cookie，JWT存放在 localStorage 中。前端的每一个请求后续都会附带上这个 JWT，整个过程压根不会涉及到 Cookie。不过，这样也会存在 XSS 攻击的风险，在 Spring 项目中，我们一般是通过创建 XSS 过滤器来避免XSS。
    - 适合移动端应用：Session 基于服务器端的状态管理，而移动端应用通常是无状态的。
14. JWT 身份认证常见问题及解决办法
    - 注销登录等场景下 JWT 还有效：JWT 一旦派发出去，如果后端不增加其他逻辑的话，它在失效之前都是有效的。
      - 解决方式：将 JWT 存入redis或黑名单机制，每次先对比
    - JWT 的续签问题：JWT 有效期一般都建议设置的不太长，那么 JWT 过期后如何认证，如何实现动态刷新 JWT，避免用户经常需要重新登录？
      - 解决方式：用户登录返回两个 JWT（推荐）：客户端登录后，将 accessJWT 和 refreshJWT 保存在本地，每次访问将 accessJWT 传给服务端。服务端校验 accessJWT 的有效性，如果过期的话，就将 refreshJWT 传给服务端。如果有效，服务端就生成新的 accessJWT 给客户端。否则，客户端就重新登录即可。
15. 如何跨域登录、登出？ 
    - 解决跨域的核心思路就是解决 Cookie 的跨域读写AuthToken问题
    - 登录完成之后通过回调的方式，将 AuthToken 传递给主域名之外的站点，该站点自行将 AuthToken 保存在当前域下的 Cookie 中。
    - 登出完成之后通过回调的方式，调用非主域名站点的登出页面，完成设置 Cookie 中的 AuthToken 过期的操作。
16. 权限模型有哪些？
    - 基于角色的访问控制（RBAC）：一个用户可以拥有若干角色，每一个角色又可以被分配若干权限
    - 基于属性的访问控制（ABAC）：是一种比 RBAC模型 更加灵活的授权模型，它的原理是通过各种属性来动态判断一个操作是否可以被允许。这个模型在云系统中使用的比较多，比如 AWS，阿里云等。
17. CAP 理论 - 对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：
    - 一致性（Consistency） : 所有节点访问同一份最新的数据副本
    - 可用性（Availability）: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。
    - 分区容错性（Partition Tolerance） : 分布式系统出现网络分区的时候，仍然能够对外提供服务。
    - ZooKeeper是 CP 架构，Eureka 就是 AP 架构，Nacos 支持 CP 架构也支持 AP 架构
18. BASE 是 Basically Available（基本可用）、Soft-state（软状态） 和 Eventually Consistent（最终一致性） 三个短语的缩写。
    - BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充。AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。
19. Zookeeper选举leader过程
    - 前提： ZK 使用 ZAB 协议（类似 Paxos），每个服务器都有 (sid, zxid)
      - sid：服务器 ID
      - zxid：最后事务 ID，用于比较谁的数据最新（zxid 是一个 64 位数字，高 32 位是 epoch（领导者任期号），低 32 位是该epoch内的事务计数器）
    - 服务器启动或 Leader 崩溃 → 进入 LOOKING 状态
    - 每个节点投票给自己（(my_sid, my_zxid)），把自己的投票广播给所有其他节点
    - 每个节点收到别人投票后，会按以下顺序比较选票： 
      - zxid 大的优先（数据更新越新越优先） 
      - 若 zxid 相同 → sid 大的优先
    - 若对方更优 → 更新自己的投票为更优的 (sid, zxid)，并继续广播更新后的投票
    - 若某个投票获得半数以上节点支持 → 选举成功，该投票的 sid 被选为 Leader，其他节点变为 Follower / Observer
    - 状态同步：Follower节点与Leader同步状态，同步完成后Leader开始处理客户端请求
20. Gossip 协议
    - 在 Gossip 协议下，没有所谓的中心节点，每个节点周期性地随机找一个节点互相同步彼此的信息，理论上来说，各个节点的状态最终会保持一致。
    - 有了 Redis Cluster 之后，不需要专门部署 Sentinel 集群服务了。Redis Cluster 相当于是内置了 Sentinel 机制，Redis Cluster 内部的各个 Redis 节点通过 Gossip 协议互相探测健康状态，在故障时可以自动切换。
21. 什么是API网关？
    - 网关主要做了两件事情：请求转发 + 请求过滤（安全认证（身份/权限认证）、流量控制、负载均衡、降级熔断、日志、监控、参数校验、协议转换）。
22. 常见的网关Spring Cloud Gateway和Zuul
    - Zuul 主要通过过滤器（类似于 AOP）来过滤请求，从而实现网关必备的各种功能。
    - Spring Cloud Gateway 和 Zuul 2.x 的差别不大，也是通过过滤器来处理请求。
    - 不过，目前更加推荐使用 Spring Cloud Gateway 而非 Zuul，Spring Cloud 生态对其支持更加友好。底层基于 Netty 实现同步非阻塞的 I/O。
23. 分布式锁的常见实现方式有哪些？
    - 基于关系型数据库比如 MySQL 实现分布式锁。
    - 基于分布式协调服务 ZooKeeper 实现分布式锁。
    - 基于分布式键值存储系统比如 Redis 、Etcd 实现分布式锁。
24. Redis分布式锁
    - 如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。
    - 可以使用Redisson中的分布式锁自带自动续期机制，原理也比较简单，其提供了一个专门用来监控和续期锁的 Watch Dog（ 看门狗），如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。
    - Redisson本身内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。
25. 基于 ZooKeeper 实现分布式锁
    - ZooKeeper 分布式锁是基于 临时顺序节点 和 Watcher（事件监听器） 实现的
    - 首先我们要有一个持久节点/locks，客户端获取锁就是在locks下创建临时顺序节点。
    - 假设客户端 1 创建了/locks/lock1节点，创建成功之后，会判断 lock1是否是 /locks 下最小的子节点。
    - 如果 lock1是最小的子节点，则获取锁成功。否则，获取锁失败。如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如/locks/lock0上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。
    - 临时节点的生命周期是与 客户端会话（session） 绑定的，会话消失则节点消失，不会发生死锁的问题。
26. RPC //todo
27. SPI（Service Provider Interface） 的具体原理是这样的：我们将接口的实现类放在配置文件中，我们在程序运行过程中读取配置文件，通过反射加载实现类。这样，我们可以在运行的时候，动态替换接口的实现类。和 IoC 的解耦思想是类似的。
28. Dubbo 提供的负载均衡策略有哪些？
    - 根据权重随机选择（对加权随机算法的实现）。这是 Dubbo 默认采用的一种负载均衡策略。
      - 假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。
      - 我们把这些权重值分布在坐标区间会得到：S1->[0, 7) ，S2->[7, 10)。我们生成[0, 10) 之间的随机数，随机数落到对应的区间，我们就选择对应的服务器来处理请求。
    - 加权轮询负载均衡
      - 轮询就是把请求依次分配给每个服务提供者。加权轮询就是在轮询的基础上，让更多的请求落到权重更大的服务提供者上。
      - 假如有两个提供相同服务的服务器 S1,S2，S1 的权重为 7，S2 的权重为 3。如果我们有 10 次请求，那么 7 次会被 S1 处理，3 次被 S2 处理。
    - 最小活跃数负载均衡
      - 每收到一个请求后，对应的服务提供者的活跃数 +1，当这个请求处理完之后，活跃数 -1。
      - 谁的活跃数越少，谁的处理速度就越快，性能也越好，这样的话，我就优先把请求给活跃数少的服务提供者处理。
      - 如果有多个服务提供者的活跃数相等怎么办？很简单，那就再走一遍 加权随机算法。
    - 一致性 Hash 负载均衡策略
      - 由请求的参数决定的，也就是说相同参数的请求总是发到同一个服务提供者。
29. ZooKeeper 应用场景
    - 命名服务：可以通过 ZooKeeper 的顺序节点生成全局唯一 ID。
    - 数据发布/订阅：通过 Watcher 机制 可以很方便地实现数据发布/订阅。当你将数据发布到 ZooKeeper 被监听的节点上，其他机器可通过监听 ZooKeeper 上节点的变化来实现配置的动态更新。
    - 分布式锁：通过创建唯一节点获得分布式锁
30. ZooKeeper 集群角色
    - Leader 既可以为客户端提供写服务又能提供读服务。
    - 除了 Leader 外，Follower 和 Observer 都只能提供读服务。
    - Follower 和 Observer 唯一的区别在于 Observer 机器不参与 Leader 的选举过程，也不参与写操作的“过半写成功”策略，因此 Observer 机器可以在不影响写性能的情况下提升集群的读性能
31. ZooKeeper 集群为啥最好奇数台？
    - ZooKeeper 集群在宕掉几个 ZooKeeper 服务器之后，如果剩下的 ZooKeeper 服务器个数大于宕掉的个数的话整个 ZooKeeper 才依然可用。
    - 2n 和 2n-1 的容忍度是一样的，都是 n-1，何必增加那一个不必要的 ZooKeeper 呢
32. ZooKeeper 选举的过半机制防止脑裂
    - 对于一个集群，通常多台机器会部署在不同机房，来提高这个集群的可用性。保证可用性的同时，会发生一种机房间网络线路故障，导致机房间网络不通，而集群被割裂成几个小集群。这时候子集群各自选主导致“脑裂”的情况。
    - ZooKeeper 的过半机制导致不可能产生 2 个 leader，因为少于等于一半是不可能产生 leader 的，这就使得不论机房的机器如何分配都不可能发生脑裂。
33. 2PC（两阶段提交）
    - 单点故障问题，如果协调者挂了那么整个系统都处于不可用的状态了。
    - 阻塞问题，即当协调者发送 prepare 请求，参与者收到之后如果能处理那么它将会进行事务的处理但并不提交，这个时候会一直占用着资源不释放，如果此时协调者挂了，那么这些资源都不会再释放了，这会极大影响性能。
    - 数据不一致问题，比如当第二阶段，协调者只发送了一部分的 commit 请求就挂了，那么也就意味着，收到消息的参与者会进行事务的提交，而后面没收到的则不会进行事务提交，那么这时候就会产生数据不一致性问题
34. 3PC（三阶段提交）
    - 3PC 在很多地方进行了超时中断的处理，比如协调者在指定时间内未收到全部的确认消息则进行事务中断的处理，这样能 减少同步阻塞的时间 。
    - 还有需要注意的是，3PC 在 DoCommit 阶段参与者如未收到协调者发送的提交事务的请求，它会在一定时间内进行事务的提交。
    - 为什么这么做呢？是因为这个时候我们肯定保证了在第一阶段所有的协调者全部返回了可以执行事务的响应，这个时候我们有理由相信其他系统都能进行事务的执行和提交，所以不管协调者有没有发消息给参与者，进入第三阶段参与者都会进行事务的提交操作。
35. K8s 微服务架构 //todo
36. 负载均衡常见的算法
    - 随机法 两次随机法
    - 轮询法
    - 哈希法 一致性 Hash 法
    - 最小连接法 最少活跃法 最快响应时间法
37. Docker和K8s的关系
    - Docker是一个轻量级的容器化平台，它允许开发人员将应用程序和其依赖项打包为可移植的容器镜像，并在不同的环境中进行部署。
    - Kubernetes是一个开源的容器编排工具，用于自动化应用程序的部署、伸缩和管理。它提供了高度可靠性的容器集群，并具有自动扩展、负载平衡和故障恢复的功能。
38. Istio服务网格是什么
    - 在Kubernetes的基础上，以非侵入的方式为运行在集群中的微服务提供流量管理、安全加固、服务监控和策略管理等功能。
    - 在数据平面由一组和业务服务成对出现的 Sidecar 代理（Envoy）构成，它的主要功能是接管服务的进出流量
39. VirtualService是什么
    - VirtualService是Istio流量治理的一个核心配置，通过VirtualService，用户可以指定如何将请求路由到目标服务的不同版本和子集，从而实现流量治理的各种需求。
    - 通过定义路由目标，可以实现诸如蓝绿部署、金丝雀发布等流量治理策略。
40. Jenkins、Pipeline
    - 流水线（Pipeline）是一种可编排的持续集成和交付（CI/CD）方法，它以代码的方式定义整个软件开发过程中的构建、测试和部署流程。
    - Pipeline 插件是 Jenkins 的默认安装插件之一，通常在安装 Jenkins 后就会自动包含。是基于 Groovy 语言的。








