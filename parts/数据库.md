- [首页](../README.md "Java Interview Docs")
1. MySQL 支持哪些存储引擎？默认使用哪个
   - 默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。存储引擎是基于表的，而不是数据库。
2. MyISAM 和 InnoDB 有什么区别
   - MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。这个恢复的过程依赖于 redo log 。
3. 并发事务带来了哪些问题
   - 脏读：一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据
   - 丢失修改：在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失
   - 不可重复读：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况
   - 幻读：在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录
4. 并发事务的控制方式有哪些
   - 锁 和 MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式
   - MVCC 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。
   - MVCC 在 MySQL 中实现所依赖的手段主要是: 隐藏字段、read view、undo log
5. SQL 标准定义了哪些事务隔离级别
   - READ-UNCOMMITTED(读取未提交) ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。
   - READ-COMMITTED(读取已提交) ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。
   - REPEATABLE-READ(可重复读) ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。
   - SERIALIZABLE(可串行化) ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。
6. MySQL 的隔离级别是基于锁实现的吗
   - InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读），是基于锁和 MVCC 机制共同实现的
7. InnoDB 有哪几类行锁
   - 记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。
   - 间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。
   - 临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。
8. MySQL 性能优化
   - 数据库只存储文件地址信息，文件由文件存储服务OSS负责存储
   - 可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小
9. SQL优化
   - 避免使用子查询，可以把子查询优化为 join 操作：子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引
   - 避免数据类型的隐式转换
   - 禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询
   - 对应同一列进行 or 判断时，使用 in 代替 or：in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引
   - WHERE 从句中禁止对列进行函数转换和计算：对列进行函数转换或计算时会导致无法使用索引
10. 索引底层数据结构选型
    - 二叉查找树(BST)：在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）
    - 平衡二叉查找树：需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了数据库写操作的性能
    - 红黑树：红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因
11. 聚簇索引与非聚簇索引
    - 聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引
    - 非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。
    - 聚簇索引只能用于主键字段的快速查询，如果想实现「非主键字段」的快速查询，我们就要针对「非主键字段」创建索引，这种索引称作为「二级索引」。二级索引同样基于 B+Tree 实现的，不过二级索引的叶子节点存放的是主键值，不是实际数据。
    - 唯一索引，普通索引，前缀索引等索引都属于二级索引
12. 覆盖索引和联合索引
    - 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 覆盖索引。直接根据该索引，就可以查到数据了，而无需回表查询。
    - 使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。
    - 联合索引的非叶子节点用各索引字段的值作为 B+Tree 的索引值
13. 非聚簇索引（二级索引）一定回表查询吗
    - 当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查(覆盖索引)
14. 最左匹配原则
    - 使用联合索引时，存在最左匹配原则，也就是按照最左优先的方式进行索引的匹配。
    - 最左匹配原则会一直向右匹配，直到遇到范围查询（如 >、<）为止。对于 >=、<=、BETWEEN 以及前缀匹配 LIKE 的范围查询，不会停止匹配。也就是范围查询的字段可以用到联合索引，但是范围查询字段的后面的字段无法用到联合索引。
    - Q1：select * from t_table where a > 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？ 
      - 只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有
    - Q2：select * from t_table where a >= 1 and b = 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
      - a 和 b 字段都用到了联合索引
15. 索引下推 //todo
    - 索引下推的下推其实就是指将部分上层（Server 层）负责的事情，交给了下层（存储引擎层）去处理
    - 索引下推的目标是减少全行读取次数，从而减少 I/O 操作。
    - 仅用于非聚簇索引，因为聚集索引，完整的记录已经读入 InnoDB 缓冲区。在这种情况下使用索引下推 不会减少 I/O
16. 正确使用索引的一些建议
    - 被频繁更新的字段应该慎重建立索引
    - 限制每张表上的索引数量
    - 尽可能的考虑建立联合索引而不是单列索引
17. MySQL IN和NOT IN会不会走索引？
18. B树和B+树的区别
     - B 树的所有节点既存放键(key)也存放数据(data),而 B+树只有叶子节点存放 key和 data,其他内节点只存放 key。
     - B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点
     - B 树中进行范围查询时,首先找到要查找的下限,然后对 B 树进行中序遍历,直到找到查找的上限;而B+树的范围查询,只需要对链表进行遍历即可
19. MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree,有什么区别
     - MyISAM索引文件和数据文件是分离的,叶节点的data 域存放的是数据记录的地址,主键索引是非聚簇索引。
     - InnoDB数据文件本身就是索引文件,叶节点data 域保存了完整的数据记录,主键索引是聚簇索引。
       - 其余的索引都作为辅助索引,辅助索引的data 域存储相应记录主键的值而不是地址。
20. 在使用XA分布式事务时,InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE
21. 解决幻读的方法:将事务隔离级别调整为 SERIALIZABLE/在可重复读的事务级别下,给事务操作的这张表添加 Next-key Lock/表锁
22. MVCC 的实现依赖于:隐藏字段、Read View、undo log。在内部实现中,InnoDB 通过数据行的 DB_TRX_ID和 Read View 来判断数据的可见性,
    如不可见,则通过数据行的DB_ROLL_PTR 找到undo log 中的历史版本。每个事务读到的数据版本可能是不一样的,
    在同一个事务中,用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改
23. redo log(重做日志)保证事务的持久性,undo log(回滚日志)来保证事务的原子性。
    MySQL 数据库的数据备份、主备、主主、主从都离不开binlog,需要依靠 binlog 来同步数据,保证数据一致性。
24. 创建一个新事务后会创建一个快照(Read View),当用户在这个事务中要读取某个记录行的时候,
    InnoDB 会将该记录行的 DB_TRX_ID与 Read View 中的一些变量及当前事务 ID 进行比较,判断是否满足可见性条件
    (如果记录 DB_TRX_ID<m_up_limit_id,那么表明最新修改该行的事务(DB_TRX_ID)在当前事务创建快照之前就提交了,所以该记录行的值对当前事务是可见的)
25. 执行计划关键字段type从最优到最差排序为:
    system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL
26. possible_keys, key, Extra
27. 自增主键不连续的情况:自增初始值和自增步长设置不为 1/唯一键冲突/事务回滚/批量插入
28. DateTime 类型是没有时区信息的(性能好),Timestamp 和时区有关(性能更差),Timestamp 表示的时间范围更小,只能到 2038年
29. 整数类型的UNSIGNED 属性有什么用?
    - 使用 UNSIGNED 属性可以将正整数的上限提高一倍,因为它不需要存储负数值。
30. 可以通过SHOW ENGINE INNODB STATUS获取死锁日志
31. 当单行数据为 1KB时，B+树3 层索引可承载 2000 万行数据,4 层索引可承载 200 多亿行
32. 每次从磁盘读取都是一整页的数据,因此读取某一行数据后,它id附近的数据行也已经在内存缓存中了,读取这一行附近的其他行不会产生磁盘I/0。
33. 何时进行分表?
    - 没有一个通用的答案,这取决于每个表的读取、新增、更新情况
      阿里巴巴 Java 开发手册上说,当单表行数超过 500 万行或单表容量超过 2GB 时,推荐进行分库分表
      从软件工程层面,如果能通过优化索引或加内存解决就不考虑分表。优先考虑读写分离+主从同步,分布式数据库。
34. 在 MySQL 启动时,Buffer Pool 会向操作系统申请一片连续的内存空间,默认为 128MB,用作内存缓存。通常建议设置为系统可用内存的 50%-75%。
35. 页是MySQL 中数据存储的基本单元,整颗B+树就是一个又一个相互使用指针连接在一起的页组成的
36. 分布式数据库:通过中间件ShardingSphere,提供全局唯一主键、跨分片查询、分布式事务等功能,将背后的多个数据库“包装”成一个逻辑上的单体数据库。
37. 如何实现读写分离？
    - MySQL Router：在 MySQL 8.2 的版本中，MySQL Router 能自动分辨对数据库读写/操作并把这些操作路由到正确的实例上，而无需在应用程序中进行任何更改。
38. 主从复制原理是什么
    - MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中
    - 如何避免主从延迟：强制将读请求路由到主库处理
39. 分库分表会带来什么问题
    - 无法使用 join 操作，group by，order by 等变得异常复杂
    - 事务问题，需要引入分布式事务
    - 引入分布式 ID生成全局唯一主键
    - 不建议分库分表，直接上 TiDB 这种分布式关系型数据库，直接一步到位
      drop、delete 与 truncate 区别
      truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segment 中，事务提交之后才生效。
40. 什么是关系型数据库
    - 建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。
41. VARCHAR(100)和 VARCHAR(10)的区别是什么
    - 虽说 VARCHAR(100)和 VARCHAR(10)能存储的字符最大长度不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的。不过，VARCHAR(100) 会消耗更多的内存。
42. DATETIME 和 TIMESTAMP 的区别是什么
    - DATETIME 类型没有时区信息，TIMESTAMP 和时区有关。
43. MySQL 基础架构
44. redo log（重做日志）、binlog（归档日志）、undo log（回滚日志）
    - MySQL InnoDB 引擎使用 redo log(重做日志) 保证事务的持久性
    - 使用 undo log(回滚日志) 来保证事务的原子性
    - MySQL 数据库的数据备份、主备、主主、主从都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性
45. redo log（重做日志）刷盘时机
    - 刷盘策略innodb_flush_log_at_trx_commit 的默认值为 1，设置为 1 的时候才不会丢失任何数据。为了保证事务的持久性，我们必须将其设置为 1。
      - 表示每次事务提交时都将进行刷盘操作
    - 另外，InnoDB 存储引擎有一个后台线程，每隔1 秒，就会把 redo log buffer 中的内容写到文件系统缓存（page cache），然后调用 fsync 刷盘。
    - 也就是说，一个没有提交事务的 redo log 记录，也可能会刷盘
46. binlog
    - binlog 是逻辑日志，记录内容是语句的原始逻辑，类似于“给 ID=2 这一行的 c 字段加 1”，属于MySQL Server 层。MySQL 数据库的数据备份、主备、主主、主从都离不开 binlog，需要依靠 binlog 来同步数据，保证数据一致性。
    - 刷盘时机：提交事务都会执行fsync，就如同 redo log 日志刷盘流程 一样。
47. 两阶段提交
    - 在执行更新语句过程，会记录 redo log 与 binlog 两块日志，以基本的事务为单位，redo log 在事务执行过程中可以不断写入，而 binlog 只有在提交事务时才写入，所以 redo log 与 binlog 的写入时机不一样。
    - 为了解决两份日志之间的逻辑一致问题，InnoDB 存储引擎使用两阶段提交方案
    - 原理很简单，将 redo log 的写入拆成了两个步骤prepare和commit，这就是两阶段提交。
    - 写入 binlog 时发生异常不会有影响，因为 MySQL 根据 redo log 日志恢复数据时，发现 redo log 还处于prepare阶段，并且没有对应 binlog 日志，就会回滚该事务。
    - 写入 redolog时发生异常也不会有影响虽然 redo log 是处于prepare阶段，但是能通过事务id找到对应的 binlog 日志，所以 MySQL 认为是完整的，就会提交事务恢复数据
48. undo log
    - 每一个事务对数据的修改都会被记录到 undo log ，当执行事务过程中出现错误或者需要执行回滚操作的话，MySQL 可以利用 undo log 将数据恢复到事务开始之前的状态
    - 另外，MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改
49. InnoDB 对 MVCC 的实现
    - MVCC 的实现依赖于：隐藏字段、Read View、undo log。在内部实现中，InnoDB 通过数据行的 DB_TRX_ID 和 Read View 来判断数据的可见性，如不可见，则通过数据行的 DB_ROLL_PTR 找到 undo log 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 Read View 之前已经提交的修改和该事务本身做的修改
50. MongoDB 存储引擎
    - WiredTiger 存储引擎，B+ 树作为其存储结构
    - MongoDB 的复合索引遵循左前缀原则
51. Mybatis——#{}和${}的区别
    - ${} 是直接替换，不会自动添加单引号，#{}会给字符串自动添加单引号
    - 使用 ${} 会出现安全问题，也就是 SQL 注入
52. 172、数据库三大范式
    - 第一范式 (1NF) - 原子性
      - 定义：一个表格处于第一范式时，表中的每一列都必须包含原子值，即列中的每个值都不能再分割成更小的部分。这意味着每个列只能有一个值，不可以有重复的或多值的集合。
    - 第二范式 (2NF) - 完全依赖
      - 定义：一个表格处于第二范式时，首先必须满足1NF，并且表中的每一列都必须完全依赖于主键，而不是仅仅依赖于主键的一部分。这通常适用于包含复合主键的表格。
    - 第三范式 (3NF) - 传递依赖
      - 定义：一个表格处于第三范式时，首先必须满足2NF，并且表中的每一列都必须直接依赖于主键，而不是通过其他非主键列间接依赖。
    - 1NF 确保每列的值是原子的，不可再分割。
    - 2NF 确保每列完全依赖于主键，消除部分依赖。
    - 3NF 确保每列直接依赖于主键，消除传递依赖。



